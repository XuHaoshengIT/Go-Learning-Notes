# Go程序的基本结构和要素

正如许多编程语言一样，第一个示例还是要拿出`hello_world` ：

```go
package main

import  "fmt"

func main() {
  fmt.Println("hello,world")
}
```

```
p.s：在Go语言中，一条完整的语句占一行，并且系统会自动默认结尾有 ";" ，不必像C家族中的其他语言那样在最后加上 ";" 。
```

*下面就是对Go程序的要素进行简要的介绍：* 

## 包

###包的基本概念：

> 包是**结构化代码**的一种方式：每个程序都由包（通常简称为 pkg）的概念组成，可以使用自身
> 的包或者从其它包中导入内容。

- 一个应用程序可以包含许多个**包** ，一个**包** 里可以包含许多个`.go` 文件。`.go` 文件中结构之类的*标识符* 是共用的，可以被直接调用。所以，一般将属于同一个包的文件放在同一个文件夹内（该文件夹的名字即为包的名字），方便开发人员查找。
- 每一个`.go` 文件都需要在非注释内容的第一行指明文件所属的*包* ，如：`package main` 。如果你打算编译包名不是为 main 的源文件时，如`pack1` ，编译后产生的对象文件将会是 `pack1.a`  （也就是`.a` 文件）而不是可执行程序。
- 另外要注意的是，所有的包名都应该使用**小写字母** 。

###标准库：

在 Go 的安装文件里包含了一些可以直接使用的包（如：`fmt` 和`os` ），即标准库。如果想了解标准库里一些包的内容，可以来这里看一下官方文档中的一些介绍：[Packages](https://golang.org/pkg/) ，当然你也可以创建自己的包。

### 包的导入：

> 一个 Go 程序是通过 `import ` 关键字将一组包链接在一起。`import "fmt"`  告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素）， fmt 包实现了格式化 IO（输入/输出）的函数。包名被封闭在半角双引号 `""` 中。如果你打算从已编译的包中导入并加载公开声明的方法(Method)，不需要插入已编译包的源代码。

如果需要多个包，它们可以被分别导入：

```go
import "fmt"
import "os"
```

或：

```go
import "fmt"; import "os"
```

但是最为常见的导入方法使用*因式分解关键字* ，这个方法同样适用`const` 、`var` 和`type` 的声明或定义：

```go
import (
	"fmt"
	"os"
)
```

> 导入包即等同于包含了这个包的所有的代码对象。
>
> 除了符号`_` ，包中所有代码对象的标识符必须是唯一的，以避免名称冲突。但是相同的标识
> 符可以在不同的包中使用，因为可以使用包名来区分它们。

### 可见性原则：

- 当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的文件所使用（当然客户端程序以及`.go` 文件中需要先导入这个包），这被称为导出；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的。

（大写字母可以使用任何 Unicode 编码的字符，比如希腊文，不仅仅是 ASCII 码中的大写字母）。

- 因此，在导入一个外部包后，能够且只能够访问该包中导出的对象。假设在包 pack1 中我们有一个变量或函数叫做 Thing（以 T 开头，所以它能够被导出），那么在当前包中导入 pack1 包，Thing 可以像面向对象语言那样使用点标记来调用：` pack1.Thing ` **（pack1 在这里是不可以省略的）** 。因此包也可以作为命名空间使用，帮助避免命名冲突（名称冲突）：两个包中的同名变量的区别在于他们的包名，例如 `pack1.Thing` 和`pack2.Thing` 。

- 你可以通过使用包的别名来解决包名之间的名称冲突，或者说根据你的个人喜好对包名进行重新设置，如： `import fm "fmt"` 。下面的代码展示了如何使用包的别名：

  **示例：** 

  ```go
  package main

  import fm "fmt" // alias3

  func main() {
    fm.Println("hello, world")
  }
  ```

  ​

```
注意事项：
如果你导入了一个包却没有使用它，则会在构建程序是引发错误，如："import and not used: os"，意思是 引入了os包却没有使用它。
```

这正是遵循了Go的格言：

####“没有不必要的代码！”



----

## 函数

这是一个较为规范的定义函数的格式：

```go
func functionName(parameter_list) (return_value_list) {
  ...
}
```

其中：

- functionName：是函数的名字，只有当某个函数需要被外部包调用的时候才使用大写字母开头，并遵循 **Pascal 命名法**[^1] ；否则就遵循骆驼命名法，即第一个单词的首字母小写，其余单词的首字母大写。有时候可能会省略


- parameter_list ：形参。一个函数有一个或多个形参，形式为 (param1 type1, param2 type2, …)。有时候可能会省略

- return_value_list ：返回值。一个函数有一个或多个返回值，形式为 (ret1 type1, ret2 type2, …)。有时候可能会省略

- `...`  ：函数里的代码（函数体），使用大括号 {} 括起来

- 左大括号`{`  必须与方法的声明放在同一行，这是编译器的强制规定，否则你在使用 gofmt
  时就会出现错误提示：``build-error: syntax error: unexpected semicolon or newline before {` ,（这是因为编译器会产生`func main() ;`  这样的结果，很明显这错误的）

- 右大括号`}`  需要被放在紧接着函数体的下一行。如果你的函数非常简短，你也可以将它们放

  在同一行：

  ```go
  func Sum(a, b int) int { return a + b }
  ```

  每一个可执行程序中必须包含一个`main` 函数，一般来说都是在启动后第一个执行的函数（如果有`init()` 函数则会先执行该函数）。**。main 函数既没有参数，也没有返回类型。** 

> 当被调用函数的代码执行到结束符 `}`  或返回语句时就会返回，然后程序继续执行调用该函数
> 之后的代码。
>
> 程序正常退出的代码为 0 即 Program exited with code 0 ；如果程序因为异常而被终止，则
> 会返回非零值，如：1。这个数值可以用来测试是否成功执行一个程序。





----

## 注释

**示例** 

```go
package main

import "fmt" // Package implementing formatted I/O

func main() {
  fmt.Printf("Mr.Xu is a good man.")
}
```

```
p.s：Package implementing formatted I/O 是注释语句，当你运行这个程序时，终端里只会显示 Mr.Xu is a good man. 不会显示任何注释内容。
```



### 注释的使用

- 每一个包都应该有一个相关的注释，位于`package` 语句前，用来对整个包的功能做简要介绍，方便开发人员了解包的一些情况；

- 在后续进行项目开发时，还需要对项目文件作版权声明，当然，也是需要用注释语句；![版权声明](E:\Go\GOPATH\src\Go-Learning-Notes\img\版权声明.png)

- 当你定义一些类型、常量、变量、函数和被导出的对象都应该有一个合理的注释，对于一些出现在函数前面的注释，例如函数Abcd，则要以`Abcd` 作为开头；**示例：** 

  ```go
  // enterOrbit cause Superman to fly into low Earth orbit, a position
  // that present several possibilities for planet salvation
  func enterOrbit() error {
      ...
  }
  ```

- 当你有一些待办的操作时，你也可以用注释语句进行标记，以免忘记在哪个位置。

### 注释符：

- `//` ：用于单行注释，你可以在任何地方使用，但是，也只能写一行；
- `/*` 、`/*` ：用于多行注释（也叫*块注释* ），均是以`/*` 开头，并以`*/` 结尾，且不可以嵌套使用。如果注释较多，可以分成段落，并且用空行分隔加以区分。


----

## 类型

不同数据类型或类型的变量（或常量）是用来保存数据的，使用`var` 声明的变量的值会自动初始化为该类型的零值，不同类型的变量能够保存数据的种类和范围是不一样的。

### 类型的分类 

- 基本类型：`int` `int8` `unit64` `float32` `float64` `bool` `string` `complex64` `complex128` 等；
- 结构化类型：`struct` `array` `slice` `map` `channel` ；
- 只描述类型行为的，如：`interface` 。

```
p.s：>    结构化类型没有真正的值，它使用nil作为默认值。其他类型的默认值后面文章有所提及。
     >	  函数也可以确定类型，就是以函数作为返回类型，这种类型的声明要写在函数名和可选的参数列表之后。
```



使用`type` 关键字可以定义自己的类型，你可以定义一个结构体（后面告诉你是什么东西），但是也可以定义一个已经存在的类型的别名，如：

```go
type IZ int
```

然后我们可以用下面的方式声明变量：

```go
var a IZ = 5
```

如果你有多个类型需要定义的话，可以使用因式分解关键字的方式，例如：

```go
type(
	IZ int
  	FZ float64
  	STR string
)
```

*每个值都必须在经过编译后属于某个类型（或者说编译器能够推断出所有值的类型），因为Go语言是一种静态类型的语言* 



----

## Go程序的一般结构

下面的这个代码是来自原书的示例，可以用来参考，（反正啥也做不了，哈哈 :-) ），不过很好的展示了一个Go程序的首选结构：

**示例：** 

```go
package main

import (
	"fmt"
)

const c = "C"

var v int = 5

type T struct{}

func init(){// initialization of package
}

func main() {
  var a int
  
  Func1()
  //...
  fmt.Println(a)
}

func (t T) Method1() {
  // ...
}

func Func1() { // exported function Func1
  // ...
}
```

```
p.s：这是一个相对规范的代码，作为新手可以写一些简单的练习程序，然后对比着该示例 的格式，对于代码规范 的内容，后续文章会有所跟进，敬请期待。
```



**代码的总体思路如下：**

- 在完成包的**import** 之后，开始对变量、常量和类型的定义或声明。
- 如果存在**init** 函数的话，则对该函数进行定义（这是一个特殊的函数，每个含有该函数的包都会首先执行这个函数）。
- 如果当前的包是**main** 包，则定义**main** 函数。
- 然后定义其余的函数，首先类型的方法，接着按照**main** 函数中先后调用的顺序来定义相关函数。




-----

##标注

1. Pascal 命名法：帕斯卡命名法，电脑程序编写是的一套命名规则（惯例），详见：[帕斯卡命名法](https://zh.wikipedia.org/wiki/%E5%B8%95%E6%96%AF%E5%8D%A1%E5%91%BD%E5%90%8D%E6%B3%95) 。


----

## List

- 上一节：[文件名、关键字与标识符](01.1.md)
- 下一节：
- 目    录：